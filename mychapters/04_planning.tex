%----------------------------------------------------------------------------
\chapter{Tervezés}
%----------------------------------------------------------------------------
Ebben a fejezetben kifejezette a tervezés lépéseit és a munka logika felépítését szeretném bemutatni. A cél röviden egy olyan rendszer létrehozása volt ami minimális felhasználói beavatkozásra képes elindítani egy szimulációs környezetet a robotról és méréseket, optimalizációkat futattni.

\section{Probléma felvetés}
A kiindulási pont a munkahelyemen fejlesztett robot, amely ROS 2-őt használ különböző funkciói végrehajtásában. Az egyik alap funkció vagy feladata az autonóm navigáció, amelyet a Nav2 stack-ben lekódolt MPPI szabályzóval valósít meg. A szabályzóhoz különféle crtic függvényeket valósítottak már meg plugin-ok formályában. Ezeknek két jellemző paramétere van: cost\_weight és cost\_power. A ezeknek a kombinációja határozza meg az MPPI által generált bevatkozó sebességekből generált pályák kiértékelését. A két paraméter hangolásával (critic-enként állítható) szabályozható, finomítható a robot viselkedése.

A korábbiakban írtam arról, hogy az autonóm navigációnál különböző feladatkörök milyen módon specifikálhatók és oszthatók szét, jelen esetben a szabályzó elsődleges feladataként a globális útvonaltervező által készített útvonal lekövetését fogalmaztam meg. Másodlagos feladatként a kinematikai korlátok: maximális és minimális sebesség, gyorsulát jelöltem ki. Értelemszerűen szükséges valamilyen határt szabni egy szabályzó feladatkörének, a használt komponensek lehetőségeit tekintve ezek a legkézenfekvőbbek.

Szóval a cél egyértelmű: bizonyos számú critic függvény paraméterének beállítása, hangolása, hogy a szabályzó képes legyen a megjelölt feladatokra. Ehhez szükséges volt egy introspekciós eszköz megtervezése és lefejlesztése, amivel képesek vagyunk monitorozni a szabályzó működését, kiértékelni különböző paraméterek hatását a robot viselkedésére. Definiálni mérhető paramétereket, amelyek alapján az összehasonlítás elvégezhető. Hosszú távú célként megfogalmazásra került, egy olyan rendszer létrehozása, amellyel hangolható autómatikusan a szabályzó paraméterei. Ezt elsősorban szimulációban a legegyszerűbb elvégezni, de a szimuláció és a valóság közötti különbségek miatt a szimulációban kapott eredményeket valós környezetben is ellenőrizni kell, tehát lehetőséget kell hagyni, hogy minimális átalakítással valós fizikai környezetben is használható legyen.

\section{Követelmények}
Egy olyan szoftver csomag létrehozása került a diplomamunka fókuszábam, amely képes a Nav2 stack-ben használt MPPI szabályzó paramétereinek monitorozására, a paraméterek hatásának vizsgálatára. Elsősorban szimulációban. A szoftvernek képesnek kell lennie:
\begin{itemize}
    \item Az eddig használt ROS 2 stack indításának támogatása launch fájlokkal.
    \item Szimulációk futtatásának lehetősége a Gazebo környezetben.
    \item Olyan paraméterek mérésének biztosítása, amelyekből eldönthető a különbség a konfigurációk között.
    \item Megismételhető és dokumentálható mérések végrehajtása, amelyek a mérhető paraméterek megfelelő kompozícióján alapulnak.
    \item A mérések eredményeinek szemléltetése, segítve a fejlesztőket a döntések meghozatalában.
    \item A szimuláció során alkalmazott paraméterek egyszerű módosíthatósága.
    \item Az optimalizáció támogatása, többek között a szimulációk párhuzamosításával.
    \item Az optimalizálási folyamat eredményeinek vizsgálata és értékelése.
\end{itemize}

A követelmények kifejtésére és megoldására az alábbi alfejezetekben írtam össze a tervezéshez levont következtétseket. A diplomamunka motivációjában is szerepet játszó alaphelyzet, miszerint egy fejlesztésben lévő robot javítása a cél, ezért megfontolások során szerepet játszott, hogy munkahelyemen agilis fejlesztési modellt alkalmazunk. Ebből kifolyólag, olyan szemlélettel terveztem a szoftvert, hogy későbbiekben bővíthető legyen. Illetve tekintve a feladat komplexitását sok helyen kompromisszumott kellett kötnöm, csökkentve a komplexitást és inkább egy minimal working example létrehozását választani. Ezeket igyekeztem kiemelni.

\subsection{Stack indítása}
ROS 2-ben launch fájlok segítésével definiálhatóak az indítandó node-ok, amelyek egy robot működéséhez szükségesek. Mivel a paraméterek kihatással vannak különböző funkciókra és a különböző más funkciók is kihatással vannak a szabályzó paramétereire ezért szükséges szem előtt tartani, hogy teljes stack futtatására is lehetőség legyen. Az összefüggések kezelése mellett a tervezés folyamán azt is figyelembe vettem, hogy fejlesztői oldalról ne legyen feltétlenül szükséges különálló launch fájlok létrehozása, ezzel munkát spórolva. Ugyanakkor, ahogy már az előző fejezetekben kifejtettem érdemes egy minimális funkcionalitás mellett elkezdeni az optimalizálást, ezzel is tisztább rálátást biztosítva a szabályzó paramemétereinek hatására. Végül úgy döntöttem létrehozok egy minimális launch fájlt ami magában foglalja a navigációnak fő komponenseit, amelyek a szabályzó működéséhez szükségesek. Ezek részletes kifejtése a következő fejezetben található.

\subsection{Szimuláció futtatása}
Mivel elsődlegesen szimulációs optimalizálást választottam vállalva ennek határait, triviális hogy követeleményként ez is szerepel. A szimulációkat úgy terveztem, hogy a lehető legkevesebb komponensét kelljen újra indítani. Ezzel idő nyerhető és komplexitás csökkenthető. Ennek következménye, hogy a robot szimulációjához és az előző pontban említett navigációs komponensek indítását külön launch fájlba szerveztem, amit elég egyszer elindítani. A mérések elvégzését és optimalizációt külön script-ek futtatásával valósítottam meg. Így egy elindított szimuláció többször felhasználható természetesen a mérések megismételhetőségét biztosítva, egyes futtatások között a megfelelő alaphelyzet visszaállításával. A szimuláció megtervezésénél szempont volt, hogy különböző a mérésekhez használt és a jövőben esetleg szükségessé váló más vagy újabb robotmodellek könnyen cserélhetőek legyenek.

\subsection{Paraméterek mérése}
Utalva a két feladat ellátásra szükséges volt mérendő paramétereket meghatározni, amikkel vizsgálható, azok teljesítése. Fontos kitétel, hogy időben rendezett módon kell ezeket összegyűjteni. Ennek többlehetősége is van ROS-on belül. Különmböző navigációs komponensek által közvetített adatok ROS-os msg-ekként jelennek meg. Adatfolyamuk folyamatosságából és diszkrétségéből adódóan azt az időpontot választottam amikor megjelennek ezek az adatok az őket felhasználó node-oknak. Általában ezek az adatok a létrehozásukkor ellátódnak egy header-nek nevezett a adatstruktúrával, amely tartalmaz időinformációt is. Viszont ez irreleváns abból szempontból, hogy a monitorozásuk közben sokkal lényegesebb mikor jutnak el az őket fogadó, váró algoritmusokhoz, mint, az, hogy mikor kreálódtak. Nyilvánvalóan ez belehozhat egyfajta torzítást az adatok elemzésébe, de az információ áramlásának sebességének késéséből adódó befolyás egy olyan hatás, amit egy jól felépített mérésnél nem okoz gondot. Az alábbi paramétereket határoztam meg:

\begin{itemize}
    \item odometria,
    \item bevatkozó sebességek,
    \item critic függvények értékei,
    \item tékrép és costmap adatok.
\end{itemize}

Az odometria mérése egyértelmű. Azt szeretnénk meghatározni, hogy a robot képes-e lekövetni egy előre meghatározott [x, y] pontok sorozatát, azaz az a szabályzó által megkapott útvonalat. Ehhez szükségünk van robot kiindulási- és célpontja közötti térben felvett koordináták halmazára, hogy későbbiekben összehasonlítást tudjunk végezni. Egy valós roboton a belső szenzorokból származó mérések zajjal terheltek, tehát itt is kiemelhető egy közelítés/elhanyagolás. Ugyanakkor szembe jön a szimulációnak egy előnye is, miszerint a zaj kiküszöbölhető. A robot aktuális pozíciójáról pontos adatot tudunk gyűjteni. Az odometria pontatlansága a szabályzó hatásfokát is befolyásolja, illetve a szabálzyó adaptivitására is kihívásként jelentkezik. Minden egyes időpillanatban a robot pozíciója és orientációja a szabályzó bemenete, így befolyásolja a generált sebességeket is. Itt is történt egy kompromisszum a fejlesztés során. Egyik fő cél a szabályzó paramétereinek behangolása során azok hatásainak elkülönítése, ezért a szimulációban a zaj kiküszöbölése mellett döntöttem. A valóságban a zaj hatását későbbiekben lehetőség szerint figyelembe kell venni.

A beavatkozó sebességek mérése is triviális. A szabályzó által generált sebességek értékeit szeretnénk monitorozni, hogy azok a kinematikai korlátoknak megfelelnek-e. Itt az MPPI szabályzó kimeneteként megjelenő sebességeket választottam. Ezekből a sebességekből gyorsulás illetve jerk számolható, amelyek szintén hasznos információt biztosítanak. Ennél a mérésnél is egyszerűsítés történt. Ez egy olyan szempontból hamis képet adhat, hogy ha általánosságban egy szabályzóról beszélünk, az általa kiszámolt bevatkozó sebesség nem feltétlenül egyezik meg a robot által végrehajtott sebességgel. Sok alkalmazásban a kinematikai határok betartására egyéb komponensek is beépíthetők, például egy sebesség szűrő ami korlátozza vagy módosítja a szabályzó által kiszámolt sebességeket, hogy gyorsulási limiteket tartson be. Az összeállított robot rendszerben az egyszerűséget és a szabályzó közvetlen működését vizsgáltam, ezért ilyen komponenst nem építettem be. Opcióként felmerült az odometriából meghatározott sebesség mérése. Ez viszont már a robot mechanikai felépítéséből adódó korlátok befolyásoló hatását is tartalmazná. Illetve megjegyzendő, hogy az MPPI kontroller elviekben tartalmazza a robot modelljét, így a kinematikai korlátokat is. Így esett választás a szabályzó által generált sebességekre.

A critic függvények működésére már kitértem az MPPI Nav2-es megvalósításának bemutatásakor. A critic függvények értékei a szabályzó által generált sebességek kiértékelésére szolgálnak. Mivel több trajektóriát generál az MPPI, mint amennyit kényelmesen és hasznosan meg lehetne jeleníteni egy diagrammon ezért a kiválasztott optimális trakjektóriához tartozó bevatkozó sebesség értékekhez tartozó score-okat választottam introsepcióhoz. Fontos kiemelni, hogy itt veszítünk egy dimenziót, hiszen nem látjuk, miként viselkednek a critic-ek egyes trajektóriánként. Ugyanakkor az agilis fejlesztési módszert követve ez is egy kompromisszum, amit vállalni kell. Későbbiekben természetesen lehetőség van ennek az átgondolására, bővítésére, amennyiben szükségessé válna.

A costmap-ről és annak értelmezéséről szintén az irodalom kutatás fejezetben szó volt, így támaszkodnék arra, hogy az olvasó minimális mégértéssel rendelkezik. A costmap lehetőséget biztosít arra, hogy információt szerezzünk a robot közelségére akadályoktól. A globális útvonal tervező szerepkörébe tartozik egy olyan útvonal legenerálása, ami nem ütközik akadályokba. Ha ezt a felvételezést követjük és azzal az egyszerűsítéssel élünk szimulációban, hogy előre meghatározott térképpel (akadályokkal) dolgozunk elégséges egyszer letervezn az útvonalat egy adott térképen. Ezt a szimulációk futtatásnál ki is használtam. Egyrészt csökkentve a számítási igényt (nem mintha használt térképek nagysága kiemelkedően megnövelné azt), másrészt biztosítva a különböző paraméterek hatásainak vizsgálatakor minél kevesebb módosítás behatását. A koncepció, hogy változtatunk paramétereket és megnézzük, hogy módosul a robot által bejárt pálya így egyetlen tervezett útvonallal hasonlítható össze. A costmap-et szintén elég egyszer elmenteni, mivel fix statikus globális térképpel dolgoztam. A megvalósítás fejezetben erre részletesen kitérek, viszont előljáróban a costmap-et is egy mérhető paraméterként kezelem. Ami lehetőséget nyújt arra, hogy a bejárt pályáról olyan következtetéseket vonjak le, amelyek jellemzik az akadályok elkerülésének minőségét. Mivel az MPPI szabályzónak dinamikus akadályok elkerülése is a feladatkörébe osztható így ilyenfajta mérések elvégzésére is lehetőség van.

\subsection{Dokumentált mérések}
Feltételként megfogalmaztam, fejlesztői munka tapasztalai és mérnöki mérések alapelvei alapján, hogy a méréseket (benchmark-okat) dokumentálni kell. Egy mérés alatt értendő a szabályzó adott paraméterekkel történő végigfuttatása egy előre meghatározott térképen, kezdőponttól célpontig. Szükségesnek találtam a mérések jellemzéséhez létrehozni egy adatstruktúrát, amelly a szoftvercsomag funkciókészletét lefedve definiálhatóvá teszi a mérést. Lehetőséget nyújta megismétlésre. ROS segítséget nyújt ebben a configurációs fájlrendszerével, amit elsősorban a szimulációban használt node-okhoz használtam. Ahogy a méréseket, úgy az optimalizációkat futtató script-ek paramétereinek is követhetőnek kell lenniük, ami alapján elemezhető a végeredmény. Felmerült egy adatbázis létrehozásának lehetősége, de nem tartottam szorosan a diplomamunka lényegének, ezért más alternatívákat választottam. Sokszor megjelent már követelményként és indokként a mérések közvetlensége a szabályzó iránt. Törekedtem a fejlesztés során, hogy minden olyan behatást, ami nem szerves része a szabályzó vizsgálatának minimálisra csökkentsek. Itt fontos szerepet játszott technológiaként a Docker konténerizáció, amely lehetővé teszi, hogy definiált verziójú szoftvereket (mint például ROS 2 humble, vagy Nav2 megfellő verziója) használjak. A konténerizáció segítségével a mérések ismételhetőek, és a mérések közötti környezeti változások minimalizálhatóak. A dokumentálhatóság, mint eladásra tervezett termék fejlesztésénél kiváltképp fontos. Elsősorban, hogy megalapozott döntés születhessen a fejlesztési irányról, másrészről, hogy későbbiekben nyoma legyen a meghozott döntések indoklásának. Tapasztalataim szerint a mérnöki munka során előnyt jelent, ha korábbi döntések revízió alá kerülésekor lehetőség van azoknak az alátámasztásait vizsgálni. Ezért is fontos a dokumentálás, kiváltképp agilis módszertan alkalmazásakor.

\subsection{Mérési eredmények szemléltetése}
Szintén utalva a fejlesztési folyamatnál fontos döntések meghozásának alátámasztására és tapasztalaimból kiindulva egy logikus grafikonból gyorsan levonhatóak jó következtetések. Ezért is feladat volt, hogy a mérések eredménye és a optimalizációk folyamata személtethető legyen. Tapasztalatok szerint a Nav2 biztosít lehetőséget vizuális elemzésre, például, amit én is alkalmaztam az MPPI szabálzyóban lehetőség van a trajektóriák vizualicációjára. Viszont ebből nem vonható le minden következtetés. Kézi hangolásnál többször találkoztunk ennek az eszköznek a korlátaival. A fejlesztés indulásakor (szintén a megvalósításról szóló fejezetbe erre részletesen kitérek) fogalmazódott meg a critic-ek vizsgálata. Ennek megoldása a critic-ek pontozásának ábrázolásával valósulhat meg. Ez egyrészt hasznos volt a diplomamunka során, másrészt hasznos introsepciós eszközzel bővití a Nav2-es MPPI szabályzót. Tervként a robot útvonalának és végigkövetett pályájának megjelenítése fogalmazódott meg, sebesség, gyorsulás és jerk értékek időbeli alakulását ábrázoló grafikonokkal és a critic értékek alakulását szointén idő szerint terveztem ábrázolni.

\subsection{Paraméterek módosításának támogatása}
Az optimalizáció során a szabályzó paramétereinek módosítása elengedhetetlen. az optimalizációs folyamat megköveteli, hogy egymásutáni méréseket futtassunk különböző paraméterekkel. Így vált egy fő tervezési elemmé a szabályzó és meleltte más node-ok paramétereinek autómatikus cseréje. A ROS 2 lehetőséget nyújt a node-ok paramétereinek kezelésére, ahogy már említettem. Ezt a rendszert használna valósítottam meg, optimalizációs algoritmusok futtatása mellé, egy olyan rendszert, ami futásidőben generálja a következő optimalizációs lépés paramétereit, az optimalizációs módszernek megfelelően. Külön mérések futtatásra során (az optimalizációt még figyelembe se véve) is előnyt jelent a gyors paraméter váltás. Célként megfogalmazódott, hogy akár két paraméter sor kiértékelésésre is legyen lehetőség. Például ha gyorsan szükségessé válna valamilyen validálás. Ezért a tervezés során a paraméterek helyes módosításának támogatása is fontos szerepet kapott.

\subsection{Optimalizáció megvalósítása}
Az optimalizáció során a cél egy olyan robusztus és rugalmas keretrendszer kialakítása volt, amely támogatja algoritmusok egymásra építését és gyors cseréjét vagy fejlesztését. Ennek érdekében olyan algoritmusokat választottam, amelyek nemcsak az aktuális feladat megoldására alkalmasak, hanem lehetőséget biztosítanak a jövőbeli bővítésekhez is. Példuál szabálzyó helyett akár útvonal tervező hatékonyságának mérésére, ha bár ez egy elég távoli terv. Az implementáció során az algoritmusok általánosítását tartottam szem előtt, hogy más, hasonló optimalizációs problémák esetében is újrafelhasználhatók legyenek és modulárisak. Itt kapcsolódok az előzőekben elhangzott mérések dokumentációjához fontos, hogy tudjuk milyen optimalizációs módszer milyen beállításokkal futott.

A párhuzamosítás szintén kulcsfontosságú szerepet kapott az optimalizációs rendszer tervezése során. Az optimalizációs folyamatok általában jelentős számítási kapacitást igényelnek, különösen, ha több konfigurációt kell kiértékelni egy szimulációs környezetben. A párhuzamosítás révén lehetőség nyílik arra, hogy egyszerre több szimuláció fusson párhuzamosan, így a teljes futási idő jelentősen csökken. Ehhez a számítási folyamatokat olyan logikával kellett felépíteni, amely támogatja a feladatok egymástól független végrehajtását, miközben biztosítja a szükséges szinkronizációt a részfeladatok eredményei között. Itt szintén nagy szerepet fog kapni a konténerizáció a megvalósításbans.

Összességében a rendszer tervezése során az optimalizációs folyamatok rugalmasságát, újrafelhasználhatóságát és hatékonyságát tartottam szem előtt. Az általánosított implementációk és a párhuzamosítás kombinációja nemcsak a jelenlegi projethez nyújt előnyöket, hanem hosszú távon is fenntartható és bővíthető megoldást biztosít. Ez a megközelítés lehetővé teszi, hogy a rendszer könnyedén adaptálható legyen újabb módszerekhez vagy változó követelményekhez, miközben minimalizálja a szükséges fejlesztési erőforrásokat.

\section{Felhasznált technológiák}
A szimulációs eszköz és az optimalizációs folyamatok megvalósításához számos technológiát alkalmaztam, amelyek lehetővé tették a rendszer gyors fejlesztését és robusztus működését. Az alábbiakban bemutatom a legfontosabb technológiákat és azok szerepét a projektben. Fókuszálva a követelményekre.

\subsection{ROS 2}
A Robot Operating System (ROS 2) a rendszer alapja, amely biztosítja a robot működéséhez szükséges node-ok kommunikációját és integrációját. Az ROS 2 használata lehetővé teszi a szabályzó paramétereinek dinamikus módosítását, a szimulációk indítását és a különféle komponensek közötti adatáramlás monitorozását. A ROS 2 Humble Hawksbill verzióját használtam, amely stabil alapot biztosított a fejlesztéshez és a szimulációhoz. A verzió választás előre determinált volt, mivel munkahelyemen fejlesztett roboton is ez fut jelenleg, ezért kompatibilitási indokból én is ebből indultam ki.

\subsection{Gazebo}
A Gazebo szimulációs környezet biztosította a robot valósághű modellezésének megközelítését és a szimulációk futtatását. A Gazebo segítségével lehetőség nyílt a robot környezetének és mozgásának pontos szimulációjára, amely elengedhetetlen volt az optimalizáció és a paraméterek vizsgálata során. A TurtleBot 3 modelleket (Burger és Waffle) használtam a teszteléshez, valamint a céges robot egyedi modelljét is integráltam a Gazebo-ba. Ezek a modellek előre már rendelkezésre álltak szóval ezekkel dolgozhattam. A párhuzamosítás kérdésében a Gazebo is szerepet játszott, klasszikus használatban egy robot egy szimulált világ a sokszor használt metódus, viszont lehetőséget nyújt több robot egy környezetben szimulálására is. Ez a funkciója bonyolultabb, mint ammennyire hasznos jelen munka során, mert a ROS 2-es node-ok, például szabályzó vagy útvonaltervező egy robotohoz használhatók, így azokat robotonként lenne szükséges futtatni külön namespace-ekben. Viszont erre az általunk használt launch fájlok nincsenek felkészítve, így jön megoldásként a Docker használata.

\subsection{Docker}
A konténerizációhoz Docker-t használtam, amely lehetővé tette az egységes fejlesztési és futtatási környezet biztosítását. A Docker segítségével a szoftver verziók és a futtatási környezetek egységesítése révén a szimulációk és mérések megismételhetősége könnyen elérhetővé vált. Ez különösen fontos volt az optimalizáció során, ahol a következetesség kulcsfontosságú a paraméterek kiértékelésében. A külön konténerekbe szeparáltságnak köszönhetően nem kell namespace-ek használatába bonyolódni, ugyanis a minden konténer saját ROS\_DOMAIN\_ID-t kap és külön port-ot a Gazebo által futtatott szimulációs szerverek. Ezzel megoldható, hogy egyszer leprogramozott algoritmusok egymás mellett, nem interferálva tudjanak párhuzamosan futni.s

\subsection{Python}
Az optimalizációs algoritmusok és a mérések automatizálására Python nyelvet használtam, amely kiváló eszköznek bizonyult a ROS 2 interfészek kezelésében és az adatelemzés megvalósításában. A szkriptek segítségével egyszerűsíteni tudtam a paraméterek automatikus módosítását és a szimulációk eredményeinek kiértékelését. A konfigurációs paramétereket YAML fájlokba rendszereztem, így téve követhetővé.

\subsection{Matplotlib és NumPy}
A mérések és az optimalizációs eredmények szemléltetésére a Matplotlib grafikus könyvtárat választottam. A grafikonok és diagramok segítették a mérések eredményeinek gyors áttekintését és az adatok mélyebb elemzését. A NumPy könyvtár lehetőséget nyújtott az adatok hatékony tárolására és feldolgozására, amely nélkülözhetetlen volt a nagy mennyiségű mérési adat kezelése során.

\subsection{Nav2 és MPPI Controller}
A Navigation 2 (Nav2) stack volt az autonóm navigáció alapja, amely a robot útvonaltervezését és pályakövetését valósította meg. Az MPPI szabályzót a Nav2-ből használtam, amely lehetővé tette a critic függvények különböző paramétereinek vizsgálatát és optimalizálását. A Nav2 moduláris felépítése és plugin-alapú kiterjeszthetősége kulcsszerepet játszott a fejlesztésben.

\section{Feladatkörök}
Egy utolsó fejezet a tervezés lépései és alapelvei között, hogy mit is vizsgáltam a szabályzó működésénél, mit tekintettem a minőségére megfogalmazható tulajdonságának, mert különféle feladatkörök és igények különíthetők el egy autonóm navigáló robot esetében, melyek szétosztása nem a legtriviálisabb feladat. Ilyenek lehetnek például a következők:
\begin{itemize}
    \item \textbf{Pályatervezés:} Két pont közötti legrövidebb és legbiztonságosabb (akadályok elkerülése szempontjából) útvonal meghatározása.
    \item \textbf{Pálya követés:} A robotnak a meghatározott pályán való haladásának biztosítása.
    \item \textbf{Kinematikai és dinamikai korlátok betartása:} A robot mozgásának sebesség vagy gyorsulás korlátok között tartása.
    \item \textbf{Akadályok elkerülése:} Dinamikus és statikus akadályok felismerése és kikerülése a mozgás során.
    \item \textbf{Hibaelhárítás:} Hibás szenzoradatok vagy váratlan környezeti hatások kezelése, hogy a robot továbbra is folytathassa a feladatát.
\end{itemize}

Ezen feladatkörök többféle alrendszerben különülhetnek el. Tervezési kérdés, hogy melyikért mi felel. A pályatervezés legtöbbször egy globális tervező feladata, amely az egész mozgástartományról készített reprezentációval dolgozik. Ez alapján határozza meg [x,y] pontok sorozatát, ami mind addig követhető, amíg nem szembesül a robot egy akadállyal, ami eredetileg a tervezés időpontjában nem keresztezte az útvonalat. Vagy nem volt a globális útvonatervező látáskörében. Ez alatt azt értem, hogy nem volt mozgástartomány reprezentációban információja, legtöbbször hiányos vagy fel nem használt szenzoradat vagy egyszerűen szenzorokkal abban az időben nem érzékelte. Így elkerülhetetlen, hogy ne fedjünk le ilyen eseteket. Ezeket meg lehet tenni másodlagos biztonsági viselkedések implementálásval, de ez kicsit túlmutat jelenlegi munka lefedettségén. Szóval maradva a klasszikus megoldásnál, ami azt jelenti bizonyos időközönként újra kell tervezni az útvonalat. Ez egyértelmű hogy a fizikai méretek távolságok növekedésével bármilyen algoritmus hasnzálatával növekszik. Ennek a számításnak leszűkítésére egy használt mód, amit a dolgozat témájaként is fókuszban levő MPPI szabályzó egyik funkciója, hogy a szabályzó veszi át az ideiglenesen az útvonal tervezés feladatát. Egy akadály megjelenésekor megpróbálja kikerülni és visszavezetni az eredeti elsődlegesen megtrervezett útvonalra a robotot. Ez a kiszervezés a szabályzó bonyolultságába, komplexitásába kerül. Ebben az esetben a szabályzó feladatkörébe kerül kiszervezésre a pálya tervezése. A pálya követés egy az egyben a szabályzó feladata, jelen munkában is így tekintek rá. Kinematikai korlátok betartását is meglehet mindkettő oldalról közelíteni. Választható olyan útvonaltervező algoritmus, amely olyan útvonalat határoz meg, amely kinematikailag bejárható, jelen esetben ilyet nem alkalmaztam, hanem a szabályzó képességét vizsgáltam ennek a teljesítésére. Az akadályok kikerülése, mint említettem egyben az útvonal megtervezését is jelenti oly módon, hogy elkerülje a robot az ütközést. Viszont a szabályzónak is feladata, hogy olyan vezérlő sebességeket generáljon melyek nem idézik elő a robot ütközését. Ennek segítésére a szenzorlefedettség az első kulcs. Olyan szenzorokkal kell felruházni a robotot melyekből kinyerhető elegendő informácó a biztonság biztosításához. Ha nem áll rendelkezésre teljes lefedettség, vagy hiányos a mozgástér valamely tartományában a robot mozgását korlátozni kellazokban az irányokban. Valós időben a szabályzó feladata lehet szintén a hibaelhárítás, amely kiegészíthető másodlagos rendszerekkel, de ezek sem alkotják a dolgozat témáját. Ilyen döntések alatt arra gondolok, hogy elakadás esetén milyen viselkedést hajtson végre. Korlátok meghozása, melyek azok a feltételek amelyek mellett még a szabályzó próbálkozzon vagy terminálja a navigációs folyamatot. Legtöbbször ezek idő vagy fizikai távolság megtételének korlátozásával írhatók le, például, ha nem képes a robot valamennyi idő alatt egy bizonyos abszolút értékben vett elmozdulást végrehajtani, vagy nem közeledik a célhoz akkor a navigációs feladatot meg kell szakítani. Nyilván ilyenkor architekturálisan magasabban elhelyezkedő rendszerek felé ezt megfelelő módon propagálni kell.

\section{Adott architektúra}
Előző fejezetben ismertettem milyen feladatkörökre bontható egy robot autonóm navigációja, most szeretném bemutatni a munkám kiindulásaként használt munkahelyemen használt architektúrát. Ez azért fontos, mert néhány helyen eltér a konvencionális megközelítéstől, tehát fontos kiemelni, milyen alapelvek motiválták a méréseket.

A robot több szenzorral is fel van szerelve (3D kamerák) viszont a diplomamunka során egy Lidar-ra szűkítettem, hogy összehasonlítható legyen a TurtleBot modellekkel, amelyeken szintén egy darab Lidar található. Lokalizációhoz AMCL-t használtam, aminek egy szenzorforrást a Lidar-t adtam meg. Egy mondatban elintézhető lenne viszont nem igazán fedné a valóságot. Olyan méréseket terveztem elkészíteni, melyeknél a lokalizációs zaj nincs hatással a szabályzó működésére, ezért a definiált kiindulási pont koordinátáit az AMCL-nek szolgáltatva minden egyes mérés előtt abba a pontba helyeztem el szimulációban a robotot, szóval ilyen szempontból nem hagyatkoztam az AMCL-re. A robot haladása közben futott az algoritmus, viszont a mérés szempontjából a szabályzóba kötött minden pillanatban aktuális pozíciót a kerekek odometriájából számoltam. A robotmodellek szimulálásánál egy Gazebo plugin biztosítja a differenciál hajtást ennek feladata a szabályzó által generált sebességek átszámolása a kerekek sebességre. Visszafelé pedig odometria biztosítása a differenciál hajtású kinematikai egyenletekkel. Szóval az olvasóban felmerülhet a kérdés, mi értelme volt az AMCL-nek? ROS-os koordináta transzformációk biztosítása különböző frame-k között.

A egy globális útvonaltervezőt használtam, amiről röviden annyit, hogy a neve NavfnPlanner és egy előre implementált algoritmus a ROS 2 Nav2 csomagjában, amely globális útvonaltervezést végez egy adott térképen. A robot alakját körként modellezi, és két algoritmus, az A* vagy a Dijkstra használatával határozza meg a legoptimálisabb útvonalat a célpont eléréséhez. Ez az algoritmus stabil, és kifejezetten az akadályokat tartalmazó környezetekben való navigációra tervezték. Nem volt a diplomamunka tárgykörébe az útvonaltervezés részletes vizsgálata, ami lényeges az az általa letervezett útvonal ami a megadott kiindulási ponttól a célponttig tartott. Olyan térképet adtam meg neki, amin virtuálisan helyeztem el akadályokat. Ez annyit jelent, hogy szimulációban fizika akadály amivel ütközni tudna a robot nem kapott helyet. A térképet az útvonaltervező a globális costmap-en keresztül kapta meg, ahol static layer-t használtam. A szabályzó szintén egy static layer-ként szereplő térképet kapott meg. Úgy terveztem, hogy ez alapesetben ugyanaz legyen, mint a globális térkép, viszont módosítható legyen, ha dinamikusan megjelenő akadályokat szeretnék szimulálni. Azaz legyen lehetőség az adott útvonalra való visszatérés sikerességét is vizsgálni.

Ezekkel az egyszerűsítéseket, kikötéseket és kompromiszumokat határoztam meg a diplomamunkában.
%----------------------------------------------------------------------------
