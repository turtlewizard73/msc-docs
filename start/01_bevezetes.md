
## 1. fejezet: Bevezetés
A diplomamunkában egy robot mozgását írányító MPPI (Model Predictive Path Integral) szabályzó paramétereinek hangolását és optimalizálási lehetőségeit vizsgálom. ROS2 (Robot Operating System) keretrendszeren belül, Gazebo szimulációs környezetben valósítom meg a szabályzó hangolását és tesztelését. A munka során különböző optimalizációs eljárásokat alkalmazok a szabályzó paramétereinek automatikus beállítására. Létrehoztam egy a szimulációs környezettel integrált szoftver csomagot, amely lehetővé teszi a futó szimulációra csatlakozva abból adatok kinyerését és feldolgozását. A mérések és kiértékelések alapján összehasonlítom a különböző optimalizációs eljárások hatékonyságát és pontosságát.

### 1.1 Autonóm navigáció kihívásai
A következő alfejezetben végigjárom a mobil robotok autonom navigációjának legfőbb problémáit egy általános leírást biztosítva a komplexitás forrásairól. Az említett algoritmusokra részletesebben kitérek a 2. fejezetben. Egy ilyen komplex probléma, mint az MPPI szabályzó hangolása, számos egymásra épülő és kölcsönösen összefüggő tényezőtől függ. Ezek magukban foglalják az alaprendszer működését (ROS2 és Nav2), a szabályzó paramétereinek beállítását (MPPI), és a megvalósítás specifikus kihívásait (szimuláció, optimalizáció).

#### 1.1.1 Általános probléma bemutatása
Robotika egyik komplex problémája az autonóm navigáció, amely során a robotnak egy adott pontból egy másikba kell eljutnia. Az összetettségét növeli, hogy a robotnak számos feladatot kell ellátnia a navigáció során. Az útvonaltervezés, a mozgásvezérlés és a helymeghatározás együttesen alkotják a robot navigációs és lokalizációs rendszerét. Mindegyik alrendszernek külön-külön kritériumoknak kell megfeleni ahhoz, hogy a robot hatékonyan és biztonságosan tudjon mozogni a környezetben. Tovább növeli a probléma bonyolultságát, hogy az egyes alrendszerek paramétereinek beállítása nem triviális feladat, egymásra épülő viselkedésük miatt a paraméterek finomhangolása kritikus jelentőségű. Sokszor feketedobozként, nem triviálisan látható módon, egymást befolyásolva működnek az egyes alrendszerek.
Nehéz észrevenni az alrendszerek paramétereinek módosításainak kihatását, következményét az egész robotra tekintve. Sokszor szükséges különböző alrendszerekben (pl. navigáció és lokalizáció) algoritmusok paramétereinek együttes vizsgálata és hangolás. A hangolás gyakran iteratív folyamat, amely során a robotot többször is tesztelni kell a kívánt viselkedés eléréséig.

#### 1.1.2 Implementáció és keretrendszer problémája
A navigációhoz vagy lokalizációhoz használt algotirmusok megértése az egyik útja a kívánt viselkedés elérésének viszont a megértés egy gyakran nagy kihívást jelentő feladat egy fejelsztő számára. Ahhoz, hogy például egy MPPI szabálzóval irányítható legyen a robot, hosszú a fejlesztési folyamat, maga az algoritmus kitalálásától a paraméterek behangolásáig. ROS2-őn belül mozgásvezérlésre, a letervezett útvonalon a robot végigvezetésére kívánt beavatkozó sebességek meghatározására több szabályzó közül lehet választani. Természetesen saját magunk is implementálhatunk egy algoritmus, viszont a NAV2, az ipari szabványoknak megfelelést célul kitűző mobil robotnavigációs rendszer biztosít előre lekódolt megoldásokat. Egyik ilyen az MPPI szabályzó, előre definiált, de bővíthető kritériumokkal, állítható paraméterekkel. A nagy előnye, hogy magával a szabályzó megírásával nem kell foglalkozni, csak a ROS2-es környezetbe való beépítésével. Ez egyértelműen megkönnyíti, lerövidíti a fejlesztési időt, viszont bonyolítja a paraméter változtatások kihatásának megértését.

A legegyszerűbb és legtisztább módja az optimális viselkedés elérésének, hogy lekódoljuk a matematikailag levezetett képletekből az algoritmust és itt saját megvalósítás alapján, saját megértés alapján akár levezethető a tényezők kívánt értéke. De ez kifejezetten időigényes és nyilván egy ipari fejlesztési folyamatban nem a legkifizetődőbb megoldás. A ROS2 meggyorsítja a fejlesztési folyamatot, mert rengeteg nyílt forráskódú előre implementált hardver illesztőprogramot, szenzoradatok feldolgozását támogató, térképezést, navígációt vagy szabályzást elvégző szoftvercsomagot és eszközt kínál, amelyek segítik a robotok gyors fejlesztését és tesztelését. Viszont ennek az a hátránya, hogy keretrendszerek halmozásával a teljes rendszerbe beleláthatóság csökken. A NAV2 szintén egy kiterjedt saját architektúrális döntésekre alapuló szoftver csomag amely kiváló általános megoldást kínál a fejlesztőknek. S mintolyan nyílt forráskódú szoftver a dokumentáció hiánya gyakran hátráltató. Továbbá a NAV2-ben lekódolt algoritmusok valamikor egy asztalon kezdték életüket képletek formályában, majd egy laborban laborkörülmények között letesztelt kutatással folytatódtak. Onnan szoftverfejlesztők implementációjával kerültek ROS2-ben használható formába. Teljesen más egy labor környezetben tesztelt algoritmus aminek célja, hogy fussun egy specifikus roboton, mint egy ROS-os implementáció, amelynek célja, hogy minél több roboton működjön általánosan. Ebben a megvalósítási folyamatban természetes módon kell kompromisszumokat hozni, integrációs döntések, architektúrális döntések, újrafelhasználhatóság, modularitás, skálázhatóság, teljesítmény tengelyeken. Ez azt eredményezi, hogy az a fejlesztő aki egy "out of the box" megoldást kíván használni természetesen egy jó kezdeti képet kap, ha elolvassa az eredeti algoritmust prezentáló cikket, viszont nem kap 100%-os átláthatóságot.

#### 1.1.3 Specifikus megoldások problémája
A másik fejlesztést nehezítő körülmény, hogy ROS-ban kínált szoftvercsomagok nem minden felhasználási esetre jók. Specifikus problémákra specifikus megoldások kellenek. Képzeljünk el egy fejlesztőt, akinek a feladata, hogy megoldja a robot eljutását egy kiindulási pontból egy célpontba. Egy hét alatt összerak ROS2 és NAV2 segítségével egy működő demót, viszont utána jön a nehéz feladat a felhasználói esetére vonatkozó funkciók implementálása, paraméterek behangolása és optimalizálása. Hogy tisztában legyen egy módosítás milyen eltérést okoz a rendszeren szüksége van egy jó dokumentációra, természetesn ha ez rendelkezésre áll elolvassa és pár iterációs körön belül egész jó eredményt tud elérni. Ha nem áll rendelkezésre vagy esetleg több helyen saját specifikus robotjára és problémájára más megoldást kellett alkalmaznia, mint ROS2 vagy NAV2 által kínált, akkor tisztában kell lennie azon részek hatásával. De az emberi megértés kapacitása is véges. Amikor már nem lehet átlátni vagy kiszámolni, analítikusan levezetni jön a mérnöki megoldás, hogy mérünk. Megváltoztatunk paramétereket és mérjük az azokra adott változást.

#### 1.1.4 Időigényesség és szimuláció
Sokszor szükséges a paraméterek manuális beállítása, amely időigényes és nem biztos, hogy optimális eredményt ad. Ahogy említettem a hangolás iteratív folyamat legtöbbször, ezért nem elég egyszer lefuttatni, szükséges többszöri futtatás eredményét összehasonlítani. Ez egy kisebb kevesebb számítási kapacitást igénylő alrendszer vagy kód viszgálata során kevésbé jelent problémát. A robot összességét tekintve, ahol legtöbb paraméter hatással van egymásra az egyik módja a hangolásnak, hogy az alrendszereket optimalizáljuk megpróbálva kizárni az egymásra gyakorolt hatásukat, vagy minimalizálni azokat. Majd összegezve az alrendszereket az egész robot viselkedésére tekintve finomhangolni. Könnyíti a hangolást a szimuláció pl. Gazebo használata, ahol a robot viselkedését virtuális környezetben tesztelhetjük. A szimulációk gyorsabbak, olcsóbbak és biztonságosabbak, mint a valós környezetben történő tesztelés. Befolyásoló paraméterek könnyen módosíthatóak, így gyorsan tesztelhetjük azok hatását a robotra. Szimulációhoz kötődöen megemlítendő, hogy a mérések reprodukálhatósága is fontos. A méréseknek definitívnek kell lenniük és megismételhetőnek. Mindezekmellett a szimuláció eredően nem biztosít tökéletes hangolási feltételek, mert csak egy modellezett környezetet biztosít, amely nem feltétlenül fed le minden valós környezeti változót. Szóval szimullációban történő autómatizlát paraméter hangolás egy jó módja a fejlesztési idő spórolásának, de nem garantálja a valós környezetben való működést, tehát szükséges utána a valós környezetben is tesztelni a robotot.

#### 1.1.5 Navigációs rendszer
Csatlakozva az 1.2-es fejezethez, kicsit részletesebben tárgyalva az autonóm mobil robotok navigációját. Két főkomponense van a navigáció és lokalizáció. A lokalizáció feladatkörébe tartozik, hogy a robot el tudja magát helyezni a környezetben. Többféle módszer, algoritmus segítségevel megteheti, általánosságban szüksége van egy térképre és szenzorok által gyűjtött információkra. A navigáció eredményessége kiemelkedően függ a lokalizáció pontosságától. Ha nincs megfelelő adatunk a robot pozíciójáról akkor a feladat, hogy egy adott pozícióba eljusson igazán nehéznek bizonyul. A lokalizációhoz szükséges térkép a fizikai világ reprezentációját jelenti kvantált gép által értelmezhető formában. Lehet 3D kamera pontfelhőjéből generált vagy 2 dimenziós Lidar segítségével, a tér egy sík szeletéből készített raszteres térkép. A diplomamunka során 2 dimenziós Lidar térképen végzett navigációval foglalkozok. A lokalizáció egy ilyen térképen felelős a robot pozíciójának meghatározásáért szenzor adatok alapján. Ilyen adatok lehetnek a kerék elfordulásából a motorvezérlő által meghatározott pozíció, 3D kamerából vagy Lidar-ból alkotott robottól akadályok távolságát tartalmaző pontfelhő. Szenzorfúzióval vagy többféle szenzoradatot értelmezni képes algoritmusokkal végezhető el a lokalizáció. A jelen munka során AMCL-t (Advanced Monte Carlo Localization) használok. A navigáció feladata, hogy a robotot egy adott pontból egy másikba vezesse. A két pont közötti útvonaltervezés a NAV2-ben implementált globális és lokális útvonaltervezők segítségével történik. A globális útvonaltervező a kiindulási és célállomás közötti útvonalat határozza meg, míg a lokális útvonaltervező a robot aktuális pozíciójától a célállomás felé vezeti a robotot. Szóval a lokalizáció információt biztosít a robot abszolút pozíciójáról a környezet térképen vagyis a fizikai térben relatív pozíciójáról. Ez a számolás kezdve a térkép pontosságával és felbontásával, a szenzorok felbontóképességével, belőlük kinyert adat mintavetelezésével mind hibával terhelt. A navigációs csomagban használt globális útvonaltervező által kiszámolt útvonal ezekre a hibával terhelt infromációkra épül rá, ahol megpróbál különböző kritériumok alapján végrehajtható útvonalat tervezni. Majd a lokális kontroller ezen az útvonalon próbálja végigvezetni a robotot. Egyértelmű, hogy az autonóm navígáció rengeteg változótól függ, melyek mindegyike hatással van a minőségre.

### 1.2 Motiváció
Munkahelyemen egy mobil robot fejlesztésével foglalkozok, ahol a fentebb felsorolt problémákkal mind találkoztam már. A diplomamunka motivációjában nagy szerepet játszott, hogy MPPI szabályzót is alkalmazunk, amit eddig kézzel hangoltunk. A robot különböző felhasználói funkciók ellátására képes, az elsődleges cél kiszállítás megvalósítása, amikor a robotra helyezett tárgyakat egyik pontból a másikba kell eljuttatni. A robotnak a környezetben található akadályokat el kell kerülnie és megérkeznie pontosan a cél pozícióba. Ennek alapja a megfelelően működő navigáció. A kézi hangolás, mint ahogy már említettem egy idő és erőforrás igényes folyamat, ezért is gondoltam jó ötletnek elmélyedni a témában. Eddig különböző introspeciós eszközöket használtunk pl. sebességet, gyorsulást elemeztük grafikonokon, illetve valós környezetben akadályok között teszteltünk. Viszont ennek az a hátránya, hogy bármilyen más alrendszert vagy paramétert megváltoztatva potenciálisan igazítani kellett a szabályzó hangolásán. A diplomamunka célja többek között az is volt, hogy egy ezt segítő szoftver hozzak létre, biztosítva, hogy mérhető legyen a paraméterek megváltoztatása által indukált viselkedés módosulása.

Probléma felvetés  kapcsán, miszerint a robotnak azt a képességét szeretnénk javítani, hogy kiindulási pontból és célpontba jusson el akadályok kikerülésével, felmerülhet az olvasóban pár kérdés. Miért ROS 2 és Nav2? A kiindulási pontként az MPPI egy már implementált megoldását válaszottam, amit a Nav2 kínál. Mivel a fókusz a kontroller használatának vizsgálata és ezzel együtt paramétereinek hangolása, ezért szükség volt egy olyan környezetre, keretrendszerre, ahol megfelelően elkülönítve vizsgálható. Ezt kínálja  ROS 2, amit az irodalom kutatás fejezetben jobban kifejtek. A Nav2 egy elterjed navigációs stack, amiben a kontroller működéséhez szükséges (lokalizáció, útvonaltervezés) funkciók már implementálva vannak, így azokra nem kellett a munka során erőforrást allokálni. A komplett cél, hogy hasznos tudás, illetve későbbiek során is felhasználható szoftver legyen a végeredmény, szóval ez is indokolja a ROS 2 és Nav2 választását.
Miért pont mppi? Valós felhasználási igényre reflektálva, ahogy említtem jelenlegi munkahelyemen fejlesztett robot ezt az algoritmust használja, így közvetlenül felhasználható a diplomamunka során végzett munka. Természetesen az navigáció megoldására más irányítás is választható, ezt igyekeztem figyelembe venni oly módon, hogy az elkészített kód a jövőben bővíthető legyen minimális erőforással. Nem lehet jobb útvonalat tervezni, esetleg másik útvonal tervezőt használni? De, egyértelműen a navigáció helyességében ez a rész is nagy hangsúllyal játszik szerepet, de jelen dolgozatnak nem ez volt a fókuszában.

### 1.3 Kihívások megoldása
A felsorolt problémák, illetve körülmények tekintetében arra a következtetésre jutottam, hogy egy olyan környezetet kell létrehozni, ami moduláris, könnyen alkalmazható többféle specifikációval futó roboton. Itt gondolok arra, hogy többféle úttervező algoritmussal futtatható legyen, a beavatkozó sebességre bármilyen behatással lévő egység könnyen cserélhető és bővíthető legyen. Időben és erőforrásigényben hatékony legyen, akár párhuzamosítható legyen a futtatása. Könnyű paraméterezést biztosítson, melyek egyszerű beállításával gyorsan lehessen módosítani, illetve megismételhető, dokumentálható legyen, hogy a későbbiekben érteni lehessen adott időpillanatban hozott döntés okát. A későbbiekben részletesen kifogok térni és a választásokat indokolni, hogy miért éppen az adott technológiát választottam. Röviden egy Docker konténerben futó ROS2-höz alkalmazott Gazebo szimulációt használó szoftvercsomagot hoztam létre, és igyekeztem a fentebb felsorolt problémákra megoldást találni. A munkám folyamán igyekeztem figyelembe venni a szimulációk reprodukálhatóságát, a mérések megismételhetőségét, a paraméterek könnyű beállítását és a mérési adatok könnyű feldolgozását, és a legfontosabbat, hogy könnyen bővíthető lehessen a jövőben újabb algoritmusokkal. A fejlesztés folyamán be kellett látnom, hogy a teljesen általnos megoldás egy időt igénylő tevékenység, így kiindulásként NAV 2-ven mintaként használt turtlebot modellből indultam ki, majd bővítettem saját robotmodellel.

### 1.4 A diplomamunka célkitűzései
A munkám céljait az alábbi pontokban foglalom össze.
#### 1.4.1 Eszköz fejlesztése a MPPI szabályzó hangolásához
Meghatározni mérendő értékeket, melyek kiértékelésével egyértelműen eldönthető, hogy két szabályzó konfiguráció közül melyik bizonyul jobbnak az adott feladat elérésére. Izolált a problémára fókuszáló környezet legyen, mely minimalizálja a robot többi funkciójának kihatását a mérendő értékekre és azokból elvégzett számolásokra. A szoftvercsomag legyen egyszerű, könnyen paraméterezhető és dokumentálható. A mérések és kiértékelések megfeleljenek a megismételhetőség követleményeinek.
#### 1.4.2 Jobb paraméterek meghatározása
A NAV 2 által kínál alapból beállított paraméterek validitálása MPPI szabályzóhoz. Vizsgálva, hogy megfelelnek-e az elvárt viselkedésnek. Ha nem, megvizsgálni, lehetséges-e a paraméterek módosításával jobb viselkedést elérni. A mérések és kiértékelések során a paraméterek módosításának hatását vizsgálom.
#### 1.4.3 Paraméterhangolás kidolgozása általános robotmodellre
Általános robotmodellre vizsgálni a szabályzó működését. Különböző méretű és alakú robotokon tesztelni az alapból beállított paramétereket és egzakt következtetést levonni azok minőségéről. Ugyanazon paraméterek hatását szemléltetni másmilyen robotokon.
#### 1.4.4 Optimalizációs eljárások alkalmazása és összehasonlítása
Összehasonlítani optimalizációs eljárások eredményeit. Meghatározni, melyik optimalizációs eljárás a legjobb a paraméterek automatikus beállítására. Különböző eljárások hatékonyságát és pontosságát vizsgálni.
