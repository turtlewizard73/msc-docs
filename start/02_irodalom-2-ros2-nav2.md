TODO: get https://design.ros2.org links for all the concepts

### 2.1 ROS 2
A ROS (Robot Operating System) egy nyílt forráskódú middleware, robotikai keretrendszer. Nem teljes értékű operációs rendszer, ahogy a nevéből gondolni lehetne, hanem a robotfejlesztéshez szükséges szoftverkeretrendszerek halmaza. A munkám során ROS 2-őt használtam, ami a ROS következő generációja.
https://en.wikipedia.org/wiki/Robot_Operating_System

Egy továbbfejlesztett változáata, amelyet a modern robotika követelményeinek figyelembevételével terveztek újra. a Főbb különbségei közé tartozik a valós idejű működés támogatása, a jobb biztonsági és több szálú működés képességei, valamint a DDS (Data Distribution Service) használata a belső üzenetküldéshez, kommunikációhoz. Míg a ROS 1 a Master-Slave architektúrát használja, addig a ROS 2 a Data Distribution Service (DDS) rendszert alkalmazza, amely nagyobb megbízhatóságot, alacsonyabb késleltetést és jobb skálázhatóságot kínál. A DDS elosztott jellege lehetővé teszi a kommunikációs hibák minimalizálását, valamint támogatja a valós idejű rendszereket. Továbbá, míg a ROS 1-ben két külön könyvtár (roscpp és rospy) létezett, addig a ROS 2 központi, C nyelven íródott rcl könyvtárat használ, amely több programozási nyelvet is támogat, például Python, C++, Java és C#. A ROS 2 ezenkívül jelentős fejlődést hozott az adatformátum kezelésében is, amely több rugalmasságot kínál a szerializálás teréna belső folyamatok kommunikációjában. A ROS 2 új funkciói közé tartozik a QoS (Minőségbiztosítás) támogatása. Ez magában foglalja az üzenetek megbízhatóságára, határidejére és prioritására vonatkozó beállításokat, amelyek biztosíthatják, hogy a kritikus üzenetek időben kézbesítésre kerüljenek. A többszálú végrehajtás lehetősége node-ok és azok belső folyamatainek párhuzamos futását teszi lehetővé. így jobban ki tudja használni a modern többmagos processzorokat, mint a ROS 1. Mindezek hozzájárulnak a valós idejű feldolgozás javításához, így sokkal jobban alkalmas a komplex, ipari robotikai alkalmazások számára.
https://www.model-prime.com/blog/ros-1-vs-ros-2-what-are-the-biggest-differences

Nem célom kitérni és bemutatni teljes végletében a ROS 2 alapelveit és működését, továbbiakban a diplomamunka szempontjából lényeges funckiók, koncepciók kerülnek csak kiemelésre és tárgyalásra, a többi információ a hivatalos dokumentációban megtalálható.

#### 2.1.1 Modularitás és node-ok
ROS 2 olyan szolgáltatásokat, eszközöket nyújt, amelyek lehetővé teszik különböző számítógépekből álló rendszer hatékony együttes működtetését. Ezek közé tartozik az absztrakt hardver kezelés, rengeteg gyártó nyújt a termékükhöz (pl. szenzorokhoz, aktuátorokhoz, vagy akár teljes robotkarokhoz) ROS 2-es csomagokat és támogatást fizikai eszközhöz, gyakran szimulációs környezethez. Nyílt forráskodú, mely hozzájárul a fejlesztők közzötti együttműködéshez, a fejlesztési idő csökkentéséhez, a szoftverek újrafelhasználásához, a szabványosításhoz és a széles körű támogatáshoz. A ROS 2 alapvető építőelemei a node-ok, amelyek az alkalmazások különálló, moduláris komponensei. Minden node egy adott vagy akár több feladatot lát el, például szenzoradatok feldolgozását, mozgástervezést vagy robotvezérlést, és önállóan, más node-októl függetlenül működik. A node-ok egymással üzenetküldés útján kommunikálnak, amely lehetővé teszi az adatok hatékony megosztását, akár különböző számítógépek között is. Több kommunikációs metódus megvólsítható node-ok között, de a lényeg, hogy szabványosított működésüknek köszönhetően már elkészített, mások által lefejlesztett csomagok egyszrűen és viszonylag költségmentesen bővíthetőek saját fejlesztésű node-okkal. A ROS 2 megosztott architektúrája miatt a node-ok nem igényelnek központi vezérlést, ami növeli a rendszer robusztusságát és skálázhatóságát. Ezzel a koncepcióval a node-ok egyszerűen cserélhetők vagy újrahasznosíthatók, megkönnyítve a komplex robotikai rendszerek fejlesztését és bővítését. Egy node leprogramozásakoz a megfelelő nyelvspecifikus könyvtár node osztály implementációjából származtatjuk az osztályt, amely az objektum orientált programozás elveihez kötve örökli az interfészek, paraméterek, időzítők létrehozását.
https://docs.ros.org/en/humble/Concepts.html

#### 2.1.2 ROS 2 client library: rclpy
Több kliens programkönyvtárat (client library-t) kínál a ROS 2, amelyek lehetővé teszik a fejlesztők számára a ROS 2 rendszerrel való kommunikációt. Több nyelven biztosít klienskönyvtárat, például a kettő legelterjedtebb: C++, Python. Fejlesztői döntés alapján választható, hogy melyi megfelelőbb egy felhasználói esetre. Ha egy gyors és hatékony megoldásra van szükség, akkor egyértelműen a C++-os klienskönyvtár a megfelelő választás, ha viszont a fejlesztési idő csökkentése és a könnyű használhatóság a cél, akár egy adatvizualizációs vagy fájlkezelési problémára, akkor a Python klienskönyvtár a megfelelő választás.
TODO: picutre about rcl -> rclpy

A Python nyelvhez a rclpy csomagot használtam, amely a ROS 2 Python klienskönyvtára. Az rcl C-ben írodott API alapjaira épül és natív Python-os adatstruktúrákat használ. Külön Python kódot generál mindegy egyes ROS 2 üzenet típushoz és az ezekből létrehozott objektumokat fordítja C nyelvre, ha tovább kell küldenie az rcl rétegnek, adattovábbítás céljából. A rclpy csomag, mint client library, lehetővé teszi a Python programok számára, hogy kommunikáljanak a ROS 2 rendszerrel, például node-okat hozzanak létre, üzeneteket publikáljanak és feliratkozzanak, szolgáltatásokat hozzanak létre, paramétereket kezeljenek, módosítsanak, szimulációs időhöz férjenek hozzá. Biztosítja a logging lehetőségét és szálkezelési modellt.
https://docs.ros.org/en/foxy/Concepts/About-ROS-2-Client-Libraries.html#the-rclpy-package

#### 2.1.3 Launch fájlok
A ROS 2-es launch rendszer célja, hogy a felhasználó számára átláthatóvá tegye és összefoglalja node-ok indítását, paraméterezését és konfigurálását. Ezen kívül a rendszer figyelemmel kíséri (összeszedet logolást biztosít) és esetlegesen reagál a változásokra. A nagyobb rendszerek konfigurációja összetett lehet, ezért a launch rendszer egyik fő előnye a moduláris konfigurációk és az al újrafelhasználhatóság támogatása. Úgynevezett launch fileok írhatóak XML vagy Python nyelven. Lehetőséget biztosítanak az indítási paraméterek meghatározására (TODO: késsőbiekben részletesen), namespace-ek létrehozására (node-ok és paraméterek elkülönítése céljából), interfészek csoportosítására illetve remapping-ek készítésére (topic-ok és service-ek nevének megváltoztatására). Launch argumentumok azaz launch fájloknak megadható paraméterek (nem node paraméterek) definiálhatóak, amikből akár feltételes node indítást lehet leprogramozni, vagy különböző konfigurációk betöltése vezérelhető vagy fájlok elérési útvonala változtatható meg. Launch fájlok segítségével tehát egyszerre indítható és állítható le több node. Futás közben monitorozható és futás után log fájl megtekintésével debugolható. Rengeteg előnyt biztosítanak tehát a launch fájlok. Ebben az összefoglalóban szintén a részletekre nem, csak a munka szmepontjából lényeges tulajdonságokra tértem ki.
https://docs.ros.org/en/foxy/Tutorials/Intermediate/Launch/Launch-Main.html
https://design.ros2.org/articles/roslaunch.html

#### 2.1.4 Interfészek
A ROS 2 alkalmazások, node-ok jellemzően háromféle interfész típuson keresztül kommunikálnak: messages, services, és actions. Ezek leírására a ROS 2 egy egyszerűsített interfészleíró nyelvet (IDL) használ, amely megkönnyíti az interfész típusának forráskód-generálását több programozási nyelvre. Az IDL lehetővé teszi, hogy az interfészek adattípusai egyszer legyenek megírva szabványosított formátumban és az ezekből generált különböző nyelvű forráskód autómatikusan történjen. Minden node-nak lehet több különböző interfésze és típusunkont és bármennyi.

A publisher-subscriber kommunikációs modell a .msg típust használja. A publisher adatok továbbítására szolgál egy topic-ra, amelyet a subscriber olvas. Egy topic-ra több publisher és több subscriber is csatlakozhat, ebben az esetben mindegy egyes subscriber megkapja az üzenetet. A service-k a .srv típust használják, amely egy kérést (request) és egy választ (response) tartalmaz. A kliens küld egy kérést a szolgáltatásnak, amely válaszol a kérésre. Az action-ök a .action típust használják, amely egy kérést (goal), egy visszajelzést (feedback) és egy választ (result) tartalmaz. Az action-ök a service-ekhez hasonlóan működnek (szintén kliens-szerver modell), de megszakíthatóak és visszajelzést adnak a kliensnek a folyamat állapotáról.
https://docs.ros.org/en/foxy/Concepts/About-ROS-Interfaces.html

#### 2.1.5 Paraméterek
A paraméterek a ROS 2-ben eredendően node-okhoz kapcsolódnak. Egy node létrehozásakor definiálhatunk paramétereket, melyekkel a node futásához szükséges adatokat tárolhatunk. Ennek az implementációnak előnye, hogy modularitás és skálázhatóság elvét segíti, azaz különböző felhasználó igényeknek könnyen átszabhatóvá teszi a node-okat. Például egy szabályzó frekvenciája definiálható ilyen paraméterként, s ezáltal állíthatóvá válik különböző futás körülmények között. A paraméterek a ROS 2 node-okhoz kapcsolódnak, és azok konfigurálására szolgálnak az indításkor vagy futás közben, anélkül hogy a kódot módosítani kellene. Egy paraméter élettartama szorosan kapcsolódik a node-éhez, bár a node implementálhat olyan mechanizmusokat, amelyek az értékeket újra betöltik egy újraindítás után. Minden paraméter egy kulcsból, egy értékből és egy típusból áll, az érték különböző típusokat vehet fel. Részletesen a hivatalos dokumentációban elérhetőek a különböző típusok, amit lényeges megemlíteni, hogy a paraméterhez tartozó definit típus meggátolja, hogy futási időben a meghibásodás lehetőségét. A paraméterek nevét, típusát szükséges a node implementációjában megszabni. Az értéke opcionálisan megadható, illetve lehetőség van alapértelmezett érték megadására is. A paramétereket a node-ok indításakor is megadhatóak parancssoron, vagy node-ok launch fájlból indításakor kódból, vagy .yaml fájlból is. A paraméterek felülírhatók, tehát előre definiált alapértelmezett értéküknél egyel magasabb fokon van a launch fájl és a node "ros2 run ..." parancsal indításakor megadott érték. Ez mellett a launch fájlokban beimportált .yaml configurációs fájlokkal is felülírhatók. A .yaml fájlok nagy előnye, hogy sok paraméter esetén átláthatóbbá teszi a konfigurációt, könnyen módosítható és újrahasználható. Ugyanis egy konfigurációs fájl több node paraméterét is tárolhatja.

A paraméterek hatalmas előnye, hogy lehetőséget biztosítanak futás közbeni módosításra.  A node paramétereit futás közben API-n keresztül, vagy külső folyamatokból paraméter service-ekkel lehet módosítani. A paraméterek változását "set parameter callback" vagy "on parameter callback" függvények segítségével előre definiálni kell. Ha egyszerű értékadás történik akkor is. Ennek az az előnye, hogy olyan paraméter megváltoztatása esetén, ha olyan változik amely kihatással van a működésre (pl. frekvencia, időzítők periódusideje vagy szabályzó paraméterek) leprogramozható mi történjen a hatására. Interakcióba a paraméterekkel különféle módokon juthatunk. Egyik módja parancsoros eszköz használata a "ros2 param set/get/..." szolgáltatás, mellyel változtatni illetve értéket lekérni is tudunk. Ha autómatizálni szeretnénk, amely a diplomamunka egy fő motívuma, egy másik futó node-ból service hívással is megtehető. Minden node-hoz tartoznek service-ek amik lehetővé teszik a futás közbeni érték cserét.
https://docs.ros.org/en/foxy/Concepts/About-ROS-2-Parameters.html

#### 2.1.6 Executors
TODO: kép
Az executor-ok menedzselik ROS 2-es folyamatok végrehajtását. Az executor egy olyan entitás, amely felelős a node-ok futtatásáért és események (időzítő vagy üzenet érkezés) hatására kiváltott callback-ek végrehajtásáért. Az executor-ok lehetővé teszik a node-ok párhuzamos futását. Az executorok az alap operációs rendszeren keresztül a processzor szálait használják a folyamatok futtatására. Az executor felelős a megfelelő függvények meghívásáért üzenetek vagy események feldolgozása céljából. Ellentétben a ROS 1-el, ahol a beérkező üzeneteket a klienskönyvtár szintjén tárolták sorban, a ROS 2-ben az üzenetek a köztes rétegben (rcl) maradnak, amíg a függvények feldolgozzák őket. Ez a tervezési megközelítés összhangban van a szolgáltatás minőséget biztosító (QoS) szabályokkal, biztosítva az erőforrások hatékonyabb kezelését. Az executor-ok "wait set" mechanizmust használnak a rendelkezésre álló üzenetek figyelésére és az időzítők lejártának észlelésére, így optimalizálva a visszahívások kezelését. A ROS 2 háromféle executort kínál, amelyek eltérő felhasználási esetekre vannak szabva.

Egyszálas executor (Single-Threaded Executor) a legegyszerűbb executor, amely egyetlen szálat használ a függvényhívások sorozatos feldolgozására. Olyan node-okhoz ideális, ahol a párhuzamos futás nem szükséges vagy nem kívánatos.

Többszálas executor (Multi-Threaded Executor) a párhuzamosságot szem előtt tartva több szálat használ a visszahívások egyidejű feldolgozására. A szálak száma konfigurálható, lehetővé téve a teljesítmény jelentős növelését olyan rendszerekben, ahol nagy a függvényhívások száma terheli a rendszert vagy az alacsony késleltetés kritikus szempont. A párhuzamos feldolgozást a callback csoportok logikai szabályai határozzák meg. A callback csoportok abból a szempontból lényegesek, hogy ezek segítségével tudja értelmezni a folyamatok prioritását. Kétféle csoport létezik: a "Mutually exclusive", mely elemei nem futhatnak párhuzamosan és a "Reentrant", mely elemei párhuzamosan futtathatóak. Külöböző callback cosportokhoz tartozó folyamatok lefuthatnak párhuzamosan. Ennek nagy szerepe az adatok feldolgozásánál van, segítségükkel megakadályozhatók a versenyhelyzetek és a deadlock-ok.

Statikus egyszálas executor (Static Single-Threaded Executor) optimalizálja azokat az eseteket, ahol a node-ok szerkezete (pl. subcriber-ek, időzítők) nem változik a futásidő során. Csak egyszer vizsgálja meg a node felépítését az inicializáláskor, szemben a másik két executor-ral, amelyek rendszeresen újravizsgálják azt. Ezért a statikus egyszálas executor-okat csak olyan node-ok esetében ajánlott használni, amelyek minden szükséges komponenst az inicializálás során hoznak létre.

https://docs.ros.org/en/foxy/Concepts/About-Executors.html

#### 2.1.7 Composition
A composition egy olyan koncepció amely megbontja a modularitását a ROS 2-es rendszernek. Teszi ezt azért, hogy gyorsabb feldolgozást nyerjen. A megszokott külön node-okban külön folyamatok helyett a node-okat lehetőség van átalakítani és "component"-ként regisztrálni, majd többet egy "container"-be betölteni. Így külön "process"-ek helyett egyben futnak. Ezt a koncepciót azért szükséges kiemelni, mert a NAV2 használja. A composion-nel megvalósíthat az "intra-process communication" (IPC), aminek lényege, hogy ugyanazokat az adatokat használó node-ok nem üzenetekkel kommunikálnak, hanem gyakorlatilag memóriacímekkel. Tehát egy container-ben indított két node ha ugyanahhoz az adathoz akar hozzáférni, a szoksásos interface-eken keresztül megteheti viszont csak virtuálisan lesz az üzenetként elküldve. Ez helyett például egy kép feldolgozó "pipeline" működésénél az adott kép memóriába töltése után a két node ugyanúgy éri el, közöttük a a kommunikáció közvetlen memóriaozáféréssel valósul meg, így gyorsítva a feldolgozást és csökkentve az erőforrás igényt. Mivel process-ek közötti kommunikáció sokkal lassabb mint az egy process-en belüli. Az IPC segítségével a különböző folyamatok közötti kommunikáció során csökkenthető az adatmásolások száma. A memóriában elhelyezett adatokat közvetlenül is megoszthatja a rendszer a folyamatok között, minimalizálva a teljesítményveszteséget. Az IPC a zero-copy technikát használhatja, amely lehetővé teszi, hogy az adatokat közvetlenül a memóriában osztják meg a résztvevő folyamatok között, további másolási műveletek nélkül. Ez különösen hasznos, ha nagy méretű üzeneteket (például szenzoradatokat vagy képeket) kell továbbítani. Mintilyen nagy méretű szenzoradatokkal dolgozo csomag a NAV2 és különböző funkciói jelentősen profitálnak belőle. Előny, hogy nem szükséges manuálisan konfigurálni az adatátvitelt; a ROS 2 maga dönti el, hogy mikor használja az IPC-t a teljesítmény javítása érdekében. Továbbá biztonságtechnikailag is jó döntés lehet, mert helyi környezetben az IPC lehetővé teszi, hogy az adatok ne kerüljenek ki a hálózatra, ezáltal csökkentve a hálózati forgalmat és a kapcsolódó késleltetést.

https://docs.ros.org/en/foxy/Concepts/About-Composition.html
https://docs.ros.org/en/foxy/Tutorials/Demos/Intra-Process-Communication.html

### 2.2 Gazebo
https://gazebosim.org/features
- robot and world models
  - ode: http://ode.org/ode-latest-userguide.html
- sensors and noise models
- plugins - interaction trough topics
### 2.3 Nav2
- core concepts https://docs.nav2.org/concepts/index.html
- frames: https://www.ros.org/reps/rep-0105.html
- costmap representation
- odometry
#### 2.3.1 Planners
#### 2.3.2 Controllers
#### 2.3.3 Costmaps
#### 2.3.4 Navigator API
### 2.4 Lokalizáció - AMCL
https://docs.nav2.org/configuration/packages/configuring-amcl.h